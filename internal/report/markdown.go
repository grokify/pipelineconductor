package report

import (
	"fmt"
	"strings"
	"time"

	"github.com/grokify/pipelineconductor/pkg/model"
)

// MarkdownFormatter generates Markdown reports.
type MarkdownFormatter struct{}

// Format generates a Markdown report.
func (f *MarkdownFormatter) Format(result *model.ComplianceResult) ([]byte, error) {
	var sb strings.Builder

	// Header
	sb.WriteString("# Compliance Report\n\n")
	sb.WriteString(fmt.Sprintf("**Generated:** %s\n", result.Timestamp.Format(time.RFC3339)))
	sb.WriteString(fmt.Sprintf("**Duration:** %dms\n", result.ScanDurationMs))
	if result.Config.Profile != "" {
		sb.WriteString(fmt.Sprintf("**Profile:** %s\n", result.Config.Profile))
	}
	sb.WriteString("\n")

	// Summary
	sb.WriteString("## Summary\n\n")
	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|--------|-------|\n")
	sb.WriteString(fmt.Sprintf("| Total Repos | %d |\n", result.Summary.TotalRepos))
	sb.WriteString(fmt.Sprintf("| Compliant | %d |\n", result.Summary.CompliantRepos))
	sb.WriteString(fmt.Sprintf("| Non-Compliant | %d |\n", result.Summary.NonCompliant))
	sb.WriteString(fmt.Sprintf("| Skipped | %d |\n", result.Summary.Skipped))
	sb.WriteString(fmt.Sprintf("| Errors | %d |\n", result.Summary.Errors))
	sb.WriteString(fmt.Sprintf("| Compliance Rate | %.1f%% |\n", result.Summary.ComplianceRate))
	sb.WriteString("\n")

	// Organizations
	if len(result.Config.Orgs) > 0 {
		sb.WriteString("## Organizations\n\n")
		for _, org := range result.Config.Orgs {
			sb.WriteString(fmt.Sprintf("- %s\n", org))
		}
		sb.WriteString("\n")
	}

	// Repositories
	sb.WriteString("## Repositories\n\n")

	for _, repo := range result.Repos {
		status := "âœ… PASS"
		if !repo.Compliant {
			status = "âŒ FAIL"
		}
		if repo.Error != "" {
			status = "âš ï¸ ERROR"
		}
		if repo.Skipped {
			status = "â­ï¸ SKIP"
		}

		sb.WriteString(fmt.Sprintf("### %s %s\n\n", status, repo.Repo.FullName))

		if repo.Skipped {
			sb.WriteString(fmt.Sprintf("**Skipped:** %s\n\n", repo.SkipReason))
			continue
		}

		if repo.Error != "" {
			sb.WriteString(fmt.Sprintf("**Error:** %s\n\n", repo.Error))
			continue
		}

		// Violations
		if len(repo.Violations) > 0 {
			sb.WriteString("**Violations:**\n\n")
			for _, v := range repo.Violations {
				severityIcon := severityToIcon(v.Severity)
				sb.WriteString(fmt.Sprintf("- %s **[%s]** %s: %s\n", severityIcon, v.Severity, v.Policy, v.Message))
				if v.Remediation != "" {
					sb.WriteString(fmt.Sprintf("  - ğŸ’¡ Remediation: %s\n", v.Remediation))
				}
			}
			sb.WriteString("\n")
		}

		// Warnings
		if len(repo.Warnings) > 0 {
			sb.WriteString("**Warnings:**\n\n")
			for _, w := range repo.Warnings {
				sb.WriteString(fmt.Sprintf("- âš ï¸ [%s] %s\n", w.Code, w.Message))
			}
			sb.WriteString("\n")
		}

		// Scan time
		sb.WriteString(fmt.Sprintf("*Scanned in %dms*\n\n", repo.ScanTimeMs))
	}

	// Footer
	sb.WriteString("---\n\n")
	sb.WriteString("*Generated by [PipelineConductor](https://github.com/grokify/pipelineconductor)*\n")

	return []byte(sb.String()), nil
}

func severityToIcon(s model.Severity) string {
	switch s {
	case model.SeverityCritical:
		return "ğŸ”´"
	case model.SeverityHigh:
		return "ğŸŸ "
	case model.SeverityMedium:
		return "ğŸŸ¡"
	case model.SeverityLow:
		return "ğŸ”µ"
	case model.SeverityInfo:
		return "âšª"
	default:
		return "âšª"
	}
}
